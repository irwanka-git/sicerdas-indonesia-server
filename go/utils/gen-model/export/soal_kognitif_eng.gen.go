// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package export

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"irwanka/sicerdas/utils/gen-model/entity"
)

func newSoalKognitifEng(db *gorm.DB, opts ...gen.DOOption) soalKognitifEng {
	_soalKognitifEng := soalKognitifEng{}

	_soalKognitifEng.soalKognitifEngDo.UseDB(db, opts...)
	_soalKognitifEng.soalKognitifEngDo.UseModel(&entity.SoalKognitifEng{})

	tableName := _soalKognitifEng.soalKognitifEngDo.TableName()
	_soalKognitifEng.ALL = field.NewAsterisk(tableName)
	_soalKognitifEng.IDSoal = field.NewInt32(tableName, "id_soal")
	_soalKognitifEng.Bidang = field.NewString(tableName, "bidang")
	_soalKognitifEng.Urutan = field.NewInt32(tableName, "urutan")
	_soalKognitifEng.IDPetunjuk = field.NewInt32(tableName, "id_petunjuk")
	_soalKognitifEng.Pertanyaan = field.NewString(tableName, "pertanyaan")
	_soalKognitifEng.PertanyaanGambar = field.NewString(tableName, "pertanyaan_gambar")
	_soalKognitifEng.PilihanA = field.NewString(tableName, "pilihan_a")
	_soalKognitifEng.PilihanAGambar = field.NewString(tableName, "pilihan_a_gambar")
	_soalKognitifEng.PilihanB = field.NewString(tableName, "pilihan_b")
	_soalKognitifEng.PilihanBGambar = field.NewString(tableName, "pilihan_b_gambar")
	_soalKognitifEng.PilihanC = field.NewString(tableName, "pilihan_c")
	_soalKognitifEng.PilihanCGambar = field.NewString(tableName, "pilihan_c_gambar")
	_soalKognitifEng.PilihanD = field.NewString(tableName, "pilihan_d")
	_soalKognitifEng.PilihanDGambar = field.NewString(tableName, "pilihan_d_gambar")
	_soalKognitifEng.PilihanE = field.NewString(tableName, "pilihan_e")
	_soalKognitifEng.PilihanEGambar = field.NewString(tableName, "pilihan_e_gambar")
	_soalKognitifEng.PilihanJawaban = field.NewString(tableName, "pilihan_jawaban")
	_soalKognitifEng.UUID = field.NewString(tableName, "uuid")
	_soalKognitifEng.Paket = field.NewString(tableName, "paket")

	_soalKognitifEng.fillFieldMap()

	return _soalKognitifEng
}

type soalKognitifEng struct {
	soalKognitifEngDo soalKognitifEngDo

	ALL              field.Asterisk
	IDSoal           field.Int32
	Bidang           field.String
	Urutan           field.Int32
	IDPetunjuk       field.Int32
	Pertanyaan       field.String
	PertanyaanGambar field.String
	PilihanA         field.String
	PilihanAGambar   field.String
	PilihanB         field.String
	PilihanBGambar   field.String
	PilihanC         field.String
	PilihanCGambar   field.String
	PilihanD         field.String
	PilihanDGambar   field.String
	PilihanE         field.String
	PilihanEGambar   field.String
	PilihanJawaban   field.String
	UUID             field.String
	Paket            field.String

	fieldMap map[string]field.Expr
}

func (s soalKognitifEng) Table(newTableName string) *soalKognitifEng {
	s.soalKognitifEngDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s soalKognitifEng) As(alias string) *soalKognitifEng {
	s.soalKognitifEngDo.DO = *(s.soalKognitifEngDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *soalKognitifEng) updateTableName(table string) *soalKognitifEng {
	s.ALL = field.NewAsterisk(table)
	s.IDSoal = field.NewInt32(table, "id_soal")
	s.Bidang = field.NewString(table, "bidang")
	s.Urutan = field.NewInt32(table, "urutan")
	s.IDPetunjuk = field.NewInt32(table, "id_petunjuk")
	s.Pertanyaan = field.NewString(table, "pertanyaan")
	s.PertanyaanGambar = field.NewString(table, "pertanyaan_gambar")
	s.PilihanA = field.NewString(table, "pilihan_a")
	s.PilihanAGambar = field.NewString(table, "pilihan_a_gambar")
	s.PilihanB = field.NewString(table, "pilihan_b")
	s.PilihanBGambar = field.NewString(table, "pilihan_b_gambar")
	s.PilihanC = field.NewString(table, "pilihan_c")
	s.PilihanCGambar = field.NewString(table, "pilihan_c_gambar")
	s.PilihanD = field.NewString(table, "pilihan_d")
	s.PilihanDGambar = field.NewString(table, "pilihan_d_gambar")
	s.PilihanE = field.NewString(table, "pilihan_e")
	s.PilihanEGambar = field.NewString(table, "pilihan_e_gambar")
	s.PilihanJawaban = field.NewString(table, "pilihan_jawaban")
	s.UUID = field.NewString(table, "uuid")
	s.Paket = field.NewString(table, "paket")

	s.fillFieldMap()

	return s
}

func (s *soalKognitifEng) WithContext(ctx context.Context) *soalKognitifEngDo {
	return s.soalKognitifEngDo.WithContext(ctx)
}

func (s soalKognitifEng) TableName() string { return s.soalKognitifEngDo.TableName() }

func (s soalKognitifEng) Alias() string { return s.soalKognitifEngDo.Alias() }

func (s soalKognitifEng) Columns(cols ...field.Expr) gen.Columns {
	return s.soalKognitifEngDo.Columns(cols...)
}

func (s *soalKognitifEng) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *soalKognitifEng) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 19)
	s.fieldMap["id_soal"] = s.IDSoal
	s.fieldMap["bidang"] = s.Bidang
	s.fieldMap["urutan"] = s.Urutan
	s.fieldMap["id_petunjuk"] = s.IDPetunjuk
	s.fieldMap["pertanyaan"] = s.Pertanyaan
	s.fieldMap["pertanyaan_gambar"] = s.PertanyaanGambar
	s.fieldMap["pilihan_a"] = s.PilihanA
	s.fieldMap["pilihan_a_gambar"] = s.PilihanAGambar
	s.fieldMap["pilihan_b"] = s.PilihanB
	s.fieldMap["pilihan_b_gambar"] = s.PilihanBGambar
	s.fieldMap["pilihan_c"] = s.PilihanC
	s.fieldMap["pilihan_c_gambar"] = s.PilihanCGambar
	s.fieldMap["pilihan_d"] = s.PilihanD
	s.fieldMap["pilihan_d_gambar"] = s.PilihanDGambar
	s.fieldMap["pilihan_e"] = s.PilihanE
	s.fieldMap["pilihan_e_gambar"] = s.PilihanEGambar
	s.fieldMap["pilihan_jawaban"] = s.PilihanJawaban
	s.fieldMap["uuid"] = s.UUID
	s.fieldMap["paket"] = s.Paket
}

func (s soalKognitifEng) clone(db *gorm.DB) soalKognitifEng {
	s.soalKognitifEngDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s soalKognitifEng) replaceDB(db *gorm.DB) soalKognitifEng {
	s.soalKognitifEngDo.ReplaceDB(db)
	return s
}

type soalKognitifEngDo struct{ gen.DO }

func (s soalKognitifEngDo) Debug() *soalKognitifEngDo {
	return s.withDO(s.DO.Debug())
}

func (s soalKognitifEngDo) WithContext(ctx context.Context) *soalKognitifEngDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s soalKognitifEngDo) ReadDB() *soalKognitifEngDo {
	return s.Clauses(dbresolver.Read)
}

func (s soalKognitifEngDo) WriteDB() *soalKognitifEngDo {
	return s.Clauses(dbresolver.Write)
}

func (s soalKognitifEngDo) Session(config *gorm.Session) *soalKognitifEngDo {
	return s.withDO(s.DO.Session(config))
}

func (s soalKognitifEngDo) Clauses(conds ...clause.Expression) *soalKognitifEngDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s soalKognitifEngDo) Returning(value interface{}, columns ...string) *soalKognitifEngDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s soalKognitifEngDo) Not(conds ...gen.Condition) *soalKognitifEngDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s soalKognitifEngDo) Or(conds ...gen.Condition) *soalKognitifEngDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s soalKognitifEngDo) Select(conds ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s soalKognitifEngDo) Where(conds ...gen.Condition) *soalKognitifEngDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s soalKognitifEngDo) Order(conds ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s soalKognitifEngDo) Distinct(cols ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s soalKognitifEngDo) Omit(cols ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s soalKognitifEngDo) Join(table schema.Tabler, on ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s soalKognitifEngDo) LeftJoin(table schema.Tabler, on ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s soalKognitifEngDo) RightJoin(table schema.Tabler, on ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s soalKognitifEngDo) Group(cols ...field.Expr) *soalKognitifEngDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s soalKognitifEngDo) Having(conds ...gen.Condition) *soalKognitifEngDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s soalKognitifEngDo) Limit(limit int) *soalKognitifEngDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s soalKognitifEngDo) Offset(offset int) *soalKognitifEngDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s soalKognitifEngDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *soalKognitifEngDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s soalKognitifEngDo) Unscoped() *soalKognitifEngDo {
	return s.withDO(s.DO.Unscoped())
}

func (s soalKognitifEngDo) Create(values ...*entity.SoalKognitifEng) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s soalKognitifEngDo) CreateInBatches(values []*entity.SoalKognitifEng, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s soalKognitifEngDo) Save(values ...*entity.SoalKognitifEng) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s soalKognitifEngDo) First() (*entity.SoalKognitifEng, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entity.SoalKognitifEng), nil
	}
}

func (s soalKognitifEngDo) Take() (*entity.SoalKognitifEng, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entity.SoalKognitifEng), nil
	}
}

func (s soalKognitifEngDo) Last() (*entity.SoalKognitifEng, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entity.SoalKognitifEng), nil
	}
}

func (s soalKognitifEngDo) Find() ([]*entity.SoalKognitifEng, error) {
	result, err := s.DO.Find()
	return result.([]*entity.SoalKognitifEng), err
}

func (s soalKognitifEngDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.SoalKognitifEng, err error) {
	buf := make([]*entity.SoalKognitifEng, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s soalKognitifEngDo) FindInBatches(result *[]*entity.SoalKognitifEng, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s soalKognitifEngDo) Attrs(attrs ...field.AssignExpr) *soalKognitifEngDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s soalKognitifEngDo) Assign(attrs ...field.AssignExpr) *soalKognitifEngDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s soalKognitifEngDo) Joins(fields ...field.RelationField) *soalKognitifEngDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s soalKognitifEngDo) Preload(fields ...field.RelationField) *soalKognitifEngDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s soalKognitifEngDo) FirstOrInit() (*entity.SoalKognitifEng, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entity.SoalKognitifEng), nil
	}
}

func (s soalKognitifEngDo) FirstOrCreate() (*entity.SoalKognitifEng, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entity.SoalKognitifEng), nil
	}
}

func (s soalKognitifEngDo) FindByPage(offset int, limit int) (result []*entity.SoalKognitifEng, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s soalKognitifEngDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s soalKognitifEngDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s soalKognitifEngDo) Delete(models ...*entity.SoalKognitifEng) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *soalKognitifEngDo) withDO(do gen.Dao) *soalKognitifEngDo {
	s.DO = *do.(*gen.DO)
	return s
}
